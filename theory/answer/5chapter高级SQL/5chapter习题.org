#+title: 第五章高级SQL习题
#+PROPERTY: header-args:sql :engine postgresql :dbhost /var/run/postgresql :dbuser sd44 :database mydb
#+PROPERTY: header-args :cache yes :exports both :tangle out.txt

我没有学习 JAVA，本章触发器使用 PL/pgSQL 实现，通用编程语言换用 Qt6 C++.

1. 描述何种情况下你会选择使用嵌入式 SQL,而不是仅仅使用 SQL 或某种通用编程语言。
   + 数据库与外部环境交互，但更多偏向于通过数据库本身来实现功能。
   + 简化编码，通过嵌入式 SQL 实现通用编程语言细节，减少通用编程语言的繁文缛节。
   + 可在编译时被检查以保证语法正确性,而不是运行时。
   + 更贴近 SQL 标准。
   + 安全性。

2. 略

3. 写一个使用 JDBC 元数据特性的 Java 函数，该函数输出数据库中的所有关系列表，为每个关系显示它的属性的名称和类型。

   不会 Java，改用 QtSql……

   QtSql 较容易输出各项信息，但是数据库中属性的类型名称除外。可以外连接 pg_
   各表，也可以直接调用 information_schema 中的 tables 和 columns 属性。完整代码请参见 [[https://gitee.com/sd44/database-system-concepts/tree/master/5chapter%E9%AB%98%E7%BA%A7SQL/qtsql][gitee]]

   #+begin_src cpp
     // 这里用的SqlMOdel,其实直接用query也可以。
     QSqlQueryModel model;
     model.setQuery(
         "SELECT table_name, column_name, udt_name\
                  FROM information_schema.columns\
                  WHERE table_schema = 'public' or table_schema IS NULL\
                  order by table_name, ordinal_position, column_name; ");
     int j = model.rowCount();

     // TODO
     // 我还不知道如何像使用std::cout控制字符宽度一样使用qDebug()，这里使用std::cout
     std::cout << std::setw(20) << "table_name" << std::setw(20) << "col_name"
     << std::setw(20) << "type_name" << std::endl;

     if (j == 0) {
       std::cout << "Empty Database " << std::endl;
     }
     for (int i = 0; i < model.rowCount(); i++) {
       std::cout << std::setw(20)
                 << model.record(i).value(0).toString().toStdString()
                 << std::setw(20)
                 << model.record(i).value(1).toString().toStdString()
                 << std::setw(20)
                 << model.record(i).value(2).toString().toStdString() << std::endl;
     }
   #+end_src

4. 说明如何用触发器来保证约束“一位教师不可能在一个学期的同一个时间段在不同的
   教室里教课”。要知道，对关系 teaches 或 section 的改变都可能使约束被破坏。

   官网给的学校模式定义其实存在问题。section 关系中与时间相关的属性只有
   time_slot_id。但 time_slot.time_slot_id 是一个非 unique 的键，在
   time_slot 关系中也存在多项重复值， 仅凭此根本无法确定教课时间。本题略。

5. 略，原因同上。

6. 为了维护关系 student 的 tot_cred 属性，完成下列任务
   1) 修改定义在 take 更新时的触发器，使其对于能影响 tot_cred 值的所有更新都有效。
   2) 写一个能与关系 takes 的插入操作相关的触发器。
   3) 在什么前提下，关系 course 上不创建触发器是有道理的。

   第一问和第二问可以使用一个触发器。第三问，我的答案是在 course_id 和 credits 属性不更新的情况下，course 不影响分数，这种情况下不创建触发器是有道理的。

   这里的 tot_cred 属性仅仅是选修各科满分学分的和，这在本书前面小节已有部分
   代码，实现较简单。我在这里将 tot_cred 改造为按 4 分制计算各位学生实际获得的总学分.

   tot_cred = 学生选修各科 A\B\C\D 分级所对应的学分 point 之和。
   #+begin_src sql
     -- 我比较喜欢低耦合的小函数组合.因此以下建了grade_points表，以及函数数量多体量小

     -- 结合 4.14题来做即可。首先建立个grade_points表,映射grade到cred。

     -- 初学者要注意的是：
     -- 1, 标量子查询（返回单行单列的值）尽量加strict限定词。
     -- 2, 注意要选择候选键，不然可能无法返回单个值，造成错误。
     -- 3，此题没有要求加 DELETE触发器。但实际情况中，一般设计修改的操作一加全加触发器.
     -- 4, 一定注意NULL和非同类型数据转换，血的教训 -__-
     -- 5, 本题触发器函数中，其实应该以候选键为准，而不应该假设（course_id,id)是唯一的，略！

     DROP TABLE IF EXISTS grade_points CASCADE;
     CREATE TABLE grade_points(
         grade VARCHAR(2),
         points REAL);
     INSERT INTO grade_points
     VALUES ('A+', 4.33), ('A', 4.0), ('A-', 3.67), ('B+', 3.33),
            ('B', 3.0), ('B-',2.67), ('C+', 2.33), ('C', 2.0), ('C-', 1.67),
            ('D+', 1.33), ('D', 1.0), ('D-', 0.67), ('F', 0.0);

     -- 根据course_id和grade计算分数

     CREATE OR REPLACE FUNCTION calc_cred(cid VARCHAR(8), newgrade VARCHAR(2)) RETURNS REAL AS $$
         DECLARE
         course_points REAL;
         newcred real := 0;
     BEGIN
         IF cid IS NULL OR newgrade is NULL THEN RETURN 0;
             -- 检查给出了 empname 以及 salary
             SELECT points FROM grade_points INTO STRICT course_points
             WHERE grade = newgrade;

             SELECT course_points * credits INTO STRICT newcred
             FROM course WHERE course_id = cid;

             RETURN newcred;
         END;
     $$ LANGUAGE plpgsql;

     -- 增加或减少某学生ID的分数
     CREATE OR REPLACE FUNCTION add_cred(sid VARCHAR(5), newcred REAL) RETURNS VOID AS $$
     BEGIN
         IF newcred IS NULL THEN
             RAISE EXCEPTION 'OMFG, This shouldn''t happen';
             RETURN;
         END if;
         UPDATE student SET tot_cred = tot_cred + newcred
         WHERE ID = sid;
     END;
     $$ LANGUAGE plpgsql;

     CREATE OR REPLACE FUNCTION take_tot_cred() RETURNS trigger AS $take_tot_cred$
         DECLARE
         newcred REAL := 0;
         oldcred REAL := 0;
     BEGIN
         IF NEW.course_id IS NOT NULL AND NEW.grade IS NOT NULL THEN
             SELECT calc_cred(NEW.course_id, NEW.grade) INTO STRICT newcred;
         END if;

         IF TG_OP = 'INSERT' THEN
             PERFORM add_cred(NEW.ID, newcred);
         ELSE
             IF OLD.course_id IS NOT NULL AND OLD.grade IS NOT NULL THEN
                 SELECT calc_cred(OLD.course_id, OLD.grade) INTO STRICT oldcred;
             END IF;
             IF(NEW.ID <> OLD.ID OR NEW.course_id <> OLD.course_id OR NEW.grade <> OLD.grade) THEN
                 PERFORM add_cred(OLD.ID, -1 * oldcred);
                 PERFORM add_cred(NEW.ID, newcred);
             END IF;
         END IF;

         RETURN NEW;
     END;
     $take_tot_cred$ LANGUAGE plpgsql;

     DROP TRIGGER IF EXISTS take_tot_cred ON takes;
     CREATE TRIGGER take_tot_cred BEFORE INSERT OR UPDATE ON takes
         FOR EACH ROW EXECUTE FUNCTION take_tot_cred();
     #+end_src

7. 考虑 5-25 中的银行数据库。视图 branch_cust 定义如下：（略）
  #+begin_quote
branch(_branch_name_,branch_city, assets)
customer(_customer_name_,customer_street, cust_omer_city)
loan(_loan_number_, branch_name, amount)
borrower(_customer_name_, _loan_number_)
account(_account_number_,branch_name,balance)
depositor(_customer_name_, _account_number_)
  #+end_quote

8. 考虑上图中的银行数据库。SQL 触发器：在对账户执行 delete 操作时，对账户的
   每一个拥有者，检查它是否有其他账户，如果没有，把他从 depositor 关系删除。

   略

9. 说明如何使用 rollup 表达 group by cube(a,b,c,d);答案只允许含有一个 group by 子句。

   #+begin_src sql
     GROUP BY ROLLUP(a), ROLLUP(b),  ROLLUP(c),  ROLLUP (d) ;
#+end_src

10. 对于给定的一个关系 S(student, subject, marks)，写一个查询，利用排名操作找出总分数排在前 n 位的学生。
    #+begin_src sql
-- 注意NULL值
      SELECT student , SUM(marks) FROM S
      GROUP BY student
      ORDER BY SUM(marks) DESC NULLS LAST
      LIMIT n;

      SELECT student, SUM(marks), rank() over (ORDER BY SUM(marks) DESC NULLS LAST)
      FROM s
      GROUP BY student
      LIMIT n;
#+end_src

11. 略，见官网

12. 答：依次打印员工 dog 的各级领导

13. 不懂 JAVA，略。

14. 用 ODBC 重做习题 5.13，定义函数 void printTable(char *r)来代替原题的方法。

    我这里用 libpqxx 这个 PG 官方 C++库来实现，和 Qt Sql 一样简单易操作。以
    下为代码节选，详细代码请参见 pqxx 文件夹。

    #+begin_src cpp

      // 如果使用libpq C库的话，直接使用PGprint函数就可以。
      void printTable(const char *tabName, pqxx::work &wk) {
        pqxx::result r = wk.exec("SELECT * FROM " + wk.esc(tabName));
        // esc() 提供安全转义，防止SQL注入。

        for (auto i = 0; i < r.columns(); ++i) {
          std::cout << std::setw(15) << r.column_name(i);
        }
        std::cout << std::endl;
        for (auto const &row : r) {
          for (auto const &field : row) {
            // c_str()方法不支持二进制和blob等数据。如果想完全实现和可控的话，应当
            // 建立PostgreSQL数据类型到C++的类型映射表，脏活，累觉不爱。
            std::cout << std::setw(15) << field.c_str();
          }
          std::cout << std::endl;
        }
      }
      #+end_src

15. 考虑有两个关系的雇员数据库。

  employee(person_name, street, city)

  works(person_name, company_name, salary)

  找出一个这样的公司，它的雇员的平均工资比"First Bank Corporation"的平均工资要高。

    1. 使用合适的 SQL 函数。
       #+begin_src sql
            CREATE OR REPLACE FUNCTION high_salary(text) RETURNS TABLE(fbbank text) AS $$
                DECLARE
                minavg REAL;
            BEGIN
                SELECT AVG(salary) FROM works INTO STRICT minavg
                WHERE company_name = $1;

                RETURN QUERY SELECT company_name FROM works
                    GROUP BY company_name
                    HAVING AVG(salary) > minavg;

                RETURN;
            END;
            $$ LANGUAGE plpgsql;
         #+end_src

    2. 不使用 SQL 函数
       #+begin_src sql
           WITH avg_first AS (
               SELECT AVG(salary) AS min_avg
               FROM works
               WHERE company_name = 'First Bank Corporation'
           )
           SELECT company_name, AVG(salary) AS csalary FROM works
           GROUP BY company_name
           HAVING AVG(salary) > (SELECT min_avg FROM avg_first);
       #+end_src

16. 使用 with 子句而不是函数调用来重写 5.2.1 节的查询，返回教师数大于 12 的
     系的名称和预算。

     #+begin_src sql
   WITH dept_count AS(
       SELECT dept_name, COUNT(*) AS d_count
       FROM instructor
       GROUP BY dept_name
   )
   SELECT dept_name, budget
   FROM department NATURAL INNER JOIN dept_count
   WHERE d_count > 12;
   #+end_src

17. 嵌入式 SQL 和通用程序语言优缺点。

  略

18. 修改图 5-15 中的递归查询来定义一个关系 prereq_depth
    (course_id,prereq_id,depth).这里属性 depth 表示在课程和先修课程之间有多
    少层中间的先修关系。直接的先修课程的深度为 0.
    #+begin_src sql
      -- 先输出全部元组，用作之后检验
      select * from prereq;

      -- 直接加层depth关系就可以
      WITH RECURSIVE rec_prereq(course_id, prereq_id, depth) AS (
          SELECT course_id, prereq_id, 1
          FROM prereq
          UNION
          SELECT rec_prereq.course_id, prereq.prereq_id, depth + 1
          FROM rec_prereq, prereq
          WHERE rec_prereq.prereq_id = prereq.course_id
      )
      SELECT * FROM rec_prereq;
    #+end_src

19. 考虑关系模式

    part(_part_id_, name, cost)

    subpart(_part_id_, _subpart_id_, count)

    关系 subpart 中的一个元组（p1,p2,3)表示部件编号为 p2 的部件是部件编号为
    p1 的部件的直接子部件，并且 p1 中包含 3 个 p2.注意 p2 本身可能有自己的子
    部件。写一个递归 SQL 查询输出编号为 p-100 的部件的所有子部件。
    #+begin_src sql
      -------------------------------------------------------------------------------
      -- 示例part关系模式数据库 --
      -------------------------------------------------------------------------------

      DROP TABLE IF EXISTS subpart CASCADE;
      DROP TABLE IF EXISTS part CASCADE;
      CREATE TABLE IF NOT EXISTS part (
          part_id INT PRIMARY KEY,
          name TEXT, cost INT);

      CREATE TABLE IF NOT EXISTS subpart (
          part_id INT REFERENCES part(part_id),
          subpart_id INT,
          count INT,
          PRIMARY KEY (part_id, subpart_id) );

      INSERT INTO part VALUES (0, 'base', 1000);
      INSERT INTO part VALUES (1, 'P-100', 100),(2, 'P-101', 50),(3, 'P-102', 10),
                              (4, 'P-103', 10),(5, 'P-104', 5),(6, 'P-105', 2);

      INSERT INTO subpart VALUES(0, 1, 2);
      INSERT INTO subpart VALUES (1, 2, 10),(1, 3, 8),(2, 4, 10),(3, 5, 5),(5,6,2);

      -- part id2和id3都需要子零件id5。用于测试。

      INSERT INTO subpart VALUES (2, 5, 2);

      -------------------------------------------------------------------------------
      -- 递归查找 , tot_count 为当前子部件所需数量 --
      -------------------------------------------------------------------------------

      WITH RECURSIVE all_subpart(part_id, name, subpart_id, count, tot_count) AS (
          SELECT part_id, name, subpart_id, count, count * 1
          FROM subpart NATURAL JOIN part
          WHERE name = 'P-100' -- 这里是要查找的父零件
          UNION SELECT part.part_id, part.name, subpart.subpart_id,
                       subpart.count, subpart.count * tot_count
          FROM all_subpart, subpart NATURAL JOIN part
          WHERE part.part_id = all_subpart.subpart_id )
      SELECT subpart_id, part.name subname, tot_count
      FROM all_subpart, part WHERE part.part_id = all_subpart.subpart_id;
    #+end_src

20. 用非递归 SQL 写一个 JDBC 函数来找出 P-100 的总成本，包括它的所有子部件的
    总成本.注意考虑一个部件可能有重复出现多次的同一个子部件的情况。如果需要，
    可以在 JAVA 中使用递归。

    TODO FIXME，暂略，之后单独更新。

21. 假设有两个关系 r 和 s,r 的外码参照 s 的主码 A.描述如何用触发器实现从 s
    中删除元组时的 on delete cascade 选项。

    我认为，on delete cascade 应当是创建一个 before delete 触发器，而不是
    after delete 触发器，以保证逻辑一贯性，可能有误。另外，UPDATE 常和
    DELETE 触发器一起使用，这里一起实现。

     #+begin_src sql
       CREATE OR REPLACE FUNCTION del_cascade() RETURNS TRIGGER AS $$
           BEGIN
               IF TG_OP = 'UPDATE' AND OLD.A = NEW.A THEN
                   RETURN OLD;
               END IF;

               IF EXISTS(SELECT * FROM r WHERE r.A = OLD.A) THEN
                   DELETE FROM r WHERE r.A = OLD.A;
               END if;
           END;
       $$ LANGUAGE plpgsql;

       CREATE TRIGGER del_cascade BEFORE DELETE OR UPDATE ON s
           FOR EACH ROW EXECUTE FUNCTION del_cascade();
     #+end_src

22. 一个触发器可能引发另一个被触发的动作。大多数数据库系统都设置了嵌套的深度
    限制。解释为什么它们要这么设置。

    书中有提到，最坏情况下，在一个关系上的插入触发器里有一个动作引起同一关系
    上另一个插入操作，而新插入也引发另一个插入，导致无限循环；另外在发生的触
    发器链中，可能发生中间某触发器引发触发链首触发器被执行的情况。

23. 略

24. TODO FIXME 说明多重集合…………
    不懂。

25. 在 5.5.1 节中，我们使用习题 4.5 中的视图 student_grades 来写基于 GPA 对
    学生排名次的查询。修改这个查询，只显示前十名的学生(rank 1 - 10)。

    5.5.1 节中提到，limit 子句不支持分区,所以我们得不到每个分区的前 N 个元组；更
    甚的是，如果多个学生有相同的 GPA，则可能其中某个学生被包括到前十，而另一
    个却不在。

    #+begin_src sql
      WITH whole_rank AS (
          SELECT ID, GPA, RANK() OVER (ORDER BY gpa DESC NULLS last)
      FROM student_grades)
      SELECT * FROM whole_rank
      WHERE RANK <= 10;
      #+end_src

26. 给出一个具有两个分组的例子，它不能使用带有 cube 和 rollup 的单个 group by 子句表达。

    TODO FIXME 不会

27. Given relation s(a , b, c), show how to use the extended SQL features to
    generate a histogram of c versus a , dividing a into 20 equal-sized
    partitions (that is, where each partition contains 5 percent of the
    tuples in s, sorted by a ).

    #+begin_src sql
      SELECT a, b, c, NTILE(20) OVER (ORDER BY A DESC NULLS LAST) FROM s;
    #+end_src

28. 考虑图 5-25 中的银行数据库,以及关系 account 的 balance 属性。写一个 SQL 查询，计
    算 balance 值的直方图，从到目前最大账户余额的范围分成三个相等的区域。

    TODO 这题目什么玩意啊。。。。只是简单 ntile(n)的应用吗？
